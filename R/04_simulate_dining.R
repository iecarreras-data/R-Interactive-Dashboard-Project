#####################################################################
# Program: 04_simulate_dining.R
# Purpose: Simulates one week of student dining hall swipes based on academic
#          schedules and student personas. Accounts for course conflicts and
#          dining hall capacity.
# Inputs: ./data/student_roster.rds
#         ./data/student_enrollment.rds
#         ./data/master_schedule.rds
# Outputs: ./data/dining_swipes.rds
# Created: 7NOV2025 (IEC)
# Modified: 19NOV2025 (IEC) 
#####################################################################

# --- 1. Load Libraries and Set Global Options ---
library(tidyverse)
library(lubridate)
library(here)

options(dplyr.summarise.inform = FALSE) # Suppress messages about grouped operations
set.seed(1866) # For reproducibility

# --- 2. Define Simulation Parameters ---
message("Setting simulation parameters...")

# Simulation Timeframe
SIM_START_DATE <- as.Date("2025-10-20") # A Monday in mid-October
SIM_DAYS <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
SIM_TIMEZONE <- "America/New_York" # Consistent timezone for all timestamps

# Meal Windows (as hours from midnight)
MEAL_WINDOWS <- list(
  Breakfast = c(7.0, 9.5),
  Lunch = c(11.0, 14.0),
  Dinner = c(17.0, 19.5)
)

# Meal Durations (in minutes) - for occupancy calculation
MEAL_DURATIONS_MINS <- c(
  Breakfast = 30,
  Lunch = 30,
  Dinner = 45
)

# Dining Hall Capacities
DINING_HALL_CAPACITIES <- c(
  `Alumni Commons` = 450, # The main, large hall
  `Gus's` = 75,           # Smaller science-area cafe
  `The Burrow` = 60       # Smaller humanities-area cafe
)

# Behavioral Probabilities & Modifiers
BASE_EATING_PROBS <- c(Breakfast = 0.35, Lunch = 0.95, Dinner = 0.85)
MODIFIERS <- list(is_athlete_breakfast = 1.8, is_athlete_dinner = 1.1)

# Dining Hall Preference Weights
BUILDING_PROXIMITY <- tribble(
  ~BuildingCode, ~NearestSmallHall,
  "A", "Gus's",
  "B", "Gus's",
  "C", "The Burrow",
  "D", "The Burrow",
  "E", "Alumni Commons",
  "F", "Alumni Commons"
)

# Persona preferences - UPDATED to match all personas generated by 03_register_students.R
PERSONA_PREFERENCES <- tribble(
  ~Persona,             ~`Alumni Commons`, ~`Gus's`, ~`The Burrow`,
  "STEM Scientist",     3, 9, 1,
  "Humanities Scholar", 4, 1, 8,
  "The Artist",         3, 2, 9,
  "The Athlete",        7, 5, 2, # Added
  "Well-Rounded",       7, 4, 4  # Added
)
PREFERENCE_WEIGHTS <- list(persona = 1.0, class_before = 3.0, class_after = 1.5)


# --- 3. Load & Prepare Data ---
message("\nLoading input data...")

# CORRECTED: Load .rds files as per pipeline design
student_roster <- readRDS(here::here("data", "student_roster.rds"))
student_enrollment <- readRDS(here::here("data", "student_enrollment.rds"))
master_schedule <- readRDS(here::here("data", "master_schedule.rds"))

message("Creating the master student schedule...")

student_schedule <- student_enrollment %>%
  left_join(student_roster, by = "StudentID") %>%
  left_join(master_schedule, by = "CourseID_Section", relationship = "many-to-one") %>%
  filter(
    !is.na(Days) & Days != "",
    !is.na(StartTime) & StartTime != "" & StartTime != "N/A"
  ) %>%
  mutate(
    StartHour = as.numeric(hm(trimws(StartTime))) / 3600,
    EndHour = as.numeric(hm(trimws(EndTime))) / 3600
  ) %>%
  filter(!is.na(StartHour) & !is.na(EndHour)) %>%
  separate_rows(Days, sep = "") %>%
  rename(DayAbbrev = Days) %>%
  mutate(
    DayOfWeek = case_when(
      DayAbbrev == "M" ~ "Monday",
      DayAbbrev == "T" ~ "Tuesday",
      DayAbbrev == "W" ~ "Wednesday",
      DayAbbrev == "R" ~ "Thursday", # Academic "R"
      DayAbbrev == "h" ~ "Thursday", # Possible lowercase "h"
      DayAbbrev == "F" ~ "Friday",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(DayOfWeek)) %>%
  left_join(BUILDING_PROXIMITY, by = "BuildingCode")

message(paste0("Success! The student_schedule data frame now contains ", nrow(student_schedule), " rows.\n"))


# --- 4. Simulation Engine ---
message("Running the dining simulation engine...")

# Helper function to calculate free blocks in a student's day
calculate_free_blocks <- function(daily_schedule, day_start = 7.0, day_end = 22.0) {
  if (nrow(daily_schedule) == 0) return(tibble(free_start = day_start, free_end = day_end))
  sorted_schedule <- daily_schedule %>% arrange(StartHour)
  starts <- c(day_start, sorted_schedule$EndHour)
  ends <- c(sorted_schedule$StartHour, day_end)
  tibble(free_start = starts, free_end = ends) %>% filter(free_end > free_start)
}

# 4.1. Calculate All Free Blocks for All Students/Days
student_free_time <- student_schedule %>%
  group_by(StudentID, DayOfWeek) %>%
  nest() %>%
  mutate(free_blocks = map(data, calculate_free_blocks)) %>%
  select(StudentID, DayOfWeek, free_blocks) %>%
  unnest(free_blocks)

# 4.2. Generate Potential Meal Events
potential_swipes <- expand_grid(
  StudentID = unique(student_roster$StudentID),
  Meal = names(MEAL_WINDOWS),
  DayOfWeek = SIM_DAYS
) %>%
  left_join(student_roster, by = "StudentID")

# 4.3. Filter for Students Who Actually Eat (probabilistic choice)
prob_swipes <- potential_swipes %>%
  mutate(
    base_prob = BASE_EATING_PROBS[Meal],
    prob_eat = case_when(
      is_athlete & Meal == "Breakfast" ~ base_prob * MODIFIERS$is_athlete_breakfast,
      is_athlete & Meal == "Dinner" ~ base_prob * MODIFIERS$is_athlete_dinner,
      TRUE ~ base_prob
    ),
    prob_eat = pmin(1, prob_eat)
  ) %>%
  filter(runif(n()) < prob_eat)

# 4.4. Determine Available Time and Create a Clean "Base" Swipes Table
initial_swipes_base <- prob_swipes %>%
  mutate(
    meal_start = map_dbl(Meal, ~MEAL_WINDOWS[[.x]][1]),
    meal_end = map_dbl(Meal, ~MEAL_WINDOWS[[.x]][2])
  ) %>%
  inner_join(student_free_time, by = c("StudentID", "DayOfWeek"), relationship = "many-to-many") %>%
  mutate(
    swipe_win_start = pmax(free_start, meal_start),
    swipe_win_end = pmin(free_end, meal_end)
  ) %>%
  filter(swipe_win_end > swipe_win_start + 0.25) %>%
  group_by(StudentID, DayOfWeek, Meal) %>%
  slice_head(n = 1) %>%
  ungroup()

# 4.5. Determine Location and Timestamp by Iterating Row-by-Row
initial_swipes <- initial_swipes_base %>%
  rowwise() %>%
  mutate(
    daily_schedule = list(student_schedule %>% filter(StudentID == .env$StudentID & DayOfWeek == .env$DayOfWeek)),
    
    hall_weights = list({
      persona_prefs <- PERSONA_PREFERENCES %>% filter(Persona == .env$Persona)
      
      if (nrow(persona_prefs) > 0) {
        weights <- c(
          `Alumni Commons` = persona_prefs$`Alumni Commons` * PREFERENCE_WEIGHTS$persona,
          `Gus's` = persona_prefs$`Gus's` * PREFERENCE_WEIGHTS$persona,
          `The Burrow` = persona_prefs$`The Burrow` * PREFERENCE_WEIGHTS$persona
        )
      } else {
        weights <- c(`Alumni Commons` = 1, `Gus's` = 1, `The Burrow` = 1)
      }
      
      class_before <- daily_schedule %>% filter(EndHour <= .env$swipe_win_start) %>% arrange(desc(EndHour)) %>% slice_head(n=1)
      class_after <- daily_schedule %>% filter(StartHour >= .env$swipe_win_end) %>% arrange(StartHour) %>% slice_head(n=1)
      
      if(nrow(class_before) > 0 && !is.na(class_before$NearestSmallHall)) {
        weights[class_before$NearestSmallHall] <- weights[class_before$NearestSmallHall] + PREFERENCE_WEIGHTS$class_before
      }
      if(nrow(class_after) > 0 && !is.na(class_after$NearestSmallHall)) {
        weights[class_after$NearestSmallHall] <- weights[class_after$NearestSmallHall] + PREFERENCE_WEIGHTS$class_after
      }
      
      weights["Alumni Commons"] <- weights["Alumni Commons"] + 1 
      
      weights
    }),
    
    DiningHall = sample(names(hall_weights), size = 1, prob = hall_weights),
    
    window_mid = mean(c(swipe_win_start, swipe_win_end)),
    window_sd = (swipe_win_end - swipe_win_start) / 4,
    sim_hour = {
      t <- -1; while(t < swipe_win_start || t > swipe_win_end) { t <- rnorm(1, window_mid, window_sd) }; t
    },
    
    sim_date = SIM_START_DATE + (which(SIM_DAYS == DayOfWeek) - 1),
    
    # *** FIX: Convert fractional hours to seconds ***
    Timestamp = ymd_hms(paste(sim_date, "00:00:00"), tz = SIM_TIMEZONE) + seconds(sim_hour * 3600)
  ) %>%
  ungroup() %>%
  select(StudentID, Meal, DayOfWeek, swipe_win_start, swipe_win_end, DiningHall, Timestamp)

message(paste0("Phase 4 Complete: Generated ", nrow(initial_swipes), " ideal swipes.\n"))

# --- 5. Capacity-Based Adjustment ---
message("Phase 5: Adjusting for dining hall capacity...")

occupancy_events <- initial_swipes %>%
  mutate(
    duration_secs = MEAL_DURATIONS_MINS[Meal] * 60,
    exit_time = Timestamp + duration_secs
  ) %>%
  select(Timestamp, exit_time, DiningHall) %>%
  pivot_longer(cols = c(Timestamp, exit_time), names_to = "event_type", values_to = "time") %>%
  mutate(change = ifelse(event_type == "Timestamp", 1, -1)) %>%
  arrange(time)

occupancy_curve <- occupancy_events %>%
  group_by(DiningHall) %>%
  mutate(occupancy = cumsum(change)) %>%
  ungroup()

swipes_with_occupancy <- initial_swipes %>%
  left_join(
    occupancy_curve %>% filter(change == 1) %>% select(time, DiningHall, occupancy),
    by = c("Timestamp" = "time", "DiningHall"), relationship = "many-to-one"
  ) %>%
  mutate(capacity = DINING_HALL_CAPACITIES[DiningHall])

swipes_to_nudge <- swipes_with_occupancy %>%
  filter(occupancy > capacity)

message(paste0(" -> Identified ", nrow(swipes_to_nudge), " swipes during over-capacity periods to adjust.\n"))

# 5.3. Nudge the Timestamps and create final dataset
if (nrow(swipes_to_nudge) > 0) {
  nudged_swipes_df <- swipes_to_nudge %>%
    rowwise() %>%
    mutate(
      sim_hour_new = runif(1, swipe_win_start, swipe_win_end), 
      sim_date = SIM_START_DATE + (which(SIM_DAYS == DayOfWeek) - 1),
      
      # *** FIX: Convert fractional hours to seconds ***
      NudgedTimestamp = ymd_hms(paste(sim_date, "00:00:00"), tz = SIM_TIMEZONE) + seconds(sim_hour_new * 3600)
    ) %>%
    ungroup() %>%
    select(StudentID, DiningHall, OriginalTimestamp = Timestamp, NudgedTimestamp)
  
  final_swipes <- initial_swipes %>%
    left_join(nudged_swipes_df, by = c("StudentID", "DiningHall", "Timestamp" = "OriginalTimestamp")) %>%
    mutate(Timestamp = coalesce(NudgedTimestamp, Timestamp)) %>%
    select(StudentID, Timestamp, DiningHall) %>%
    arrange(Timestamp)
} else {
  message(" -> All students fully accommodated. No nudging needed.")
  final_swipes <- initial_swipes %>%
    select(StudentID, Timestamp, DiningHall) %>%
    arrange(Timestamp)
}

# --- 6. Finalize & Save ---
message("\n--- Simulation Complete! ---")
message(paste0("Generated ", nrow(final_swipes), " capacity-adjusted dining swipes.\n"))

message("--- A quick look at the corrected output ---")
print(head(final_swipes))
message("\n--- Swipe counts by dining hall ---")
print(table(final_swipes$DiningHall))

# CORRECTED: Save to .rds file for pipeline consistency
saveRDS(final_swipes, here::here("data", "dining_swipes.rds"))
message(paste0("\n'dining_swipes.rds' has been successfully created with the final data (", nrow(final_swipes), " swipes).\n"))